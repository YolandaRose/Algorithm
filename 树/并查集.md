# 并查集

1.定义
并查集是一种树型的数据结构，用于处理一些**不相交集合的合并及查询**问题（即所谓的并、查）。
比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。

2.主要构成
由一个整型数组`pre[ ]`和两个函数`find( )`、`join( )`构成。

- 数组 pre[ ] 记录了每个点的前驱节点是谁
- 函数 find(x) 用于查找指定节点 x 属于哪个集合
- 函数 join(x,y) 用于合并两个节点 x 和 y 。

3.作用
主要作用是求**连通分支数**（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）

## `find()`函数

- 首先我们需要定义一个数组：int pre[1000]; （数组长度依题意而定）。这个数组**记录了每个人的上级是谁**。这些人从0或1开始编号（依题意而定）。比如说pre[16]=6就表示16号的上级是6号。如果一个人的上级就是他自己，那说明他就是教主了，查找到此结束。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。

```java
int find(int x){//查找x的教主
    while(pre[x] != x){//如果x的上级不是自己（则说明找到的人不是教主）
        x = pre[x];
    }//x继续找他的上级，直到找到教主为止
    return x;//教主驾到~~~
}
```

## `join()`函数

- join(x,y)的执行逻辑如下：
1、寻找 x 的代表元（即教主）；
2、寻找 y 的代表元（即教主）；
3、如果 x 和 y 不相等，则随便选一个人作为另一个人的上级，如此一来就完成了 x 和 y 的合并。
下面给出这个函数的具体实现：

```java
void join(int x, int y){//合并x和y
    int fx=find(x), fy=find(y);//找到x和y的教主
    if(fx!=fy){//如果x和y的教主不相等
        pre[fx]=fy;//将x的教主指向y的教主
    }
}
```

## 优化`find()`函数

1.路径压缩

- 通常情况下，我们可以结合着循环来将给定的大量数据合并成为若干个更大的集合（即并查集）。但是问题也随之产生，我们来看这段代码：

```java
if(fx != fy) pre[fx]=fy;
```

这里并没有明确谁是谁的前驱（上级）的规则，而是我直接指定后面的数据作为前面数据的前驱（上级）。那么这样就导致了最终的树状结构无法预计，即有可能是良好的 n 叉树，也有可能是单支树结构（一字长蛇形）。试想，如果最后真的形成单支树结构，那么它的效率就会及其低下（树的深度过深，那么查询过程就必然耗时）。

- 而我们最理想的情况就是**所有人的直接上级都是教主**，这样一来整个树的结构就只有两级，此时查询教主只需要一次。因此，这就产生了路径压缩算法。
- 在这些节点中，除了根节点外（即曹操），其余所有节点（即夏侯惇、郭嘉、曹植）都需要更改直接前驱为曹操。
因此，基于这样的思路，我们可以通过递归的方法来逐层修改返回时的某个节点的直接前驱（即pre[x]的值）。简单说来就是将x到根节点路径上的所有点的pre（上级）都设为根节点。下面给出具体的实现代码：

```java
int find(int x){
    if(pre[x] == x)return x;//如果x的上级就是自己，则说明x就是教主，直接返回
    return pre[x] = find(pre[x]);//否则，递归地找到x的教主，并将其作为x的直接前驱
}
```

- 该算法存在一个缺陷：只有当查找了某个节点的代表元（教主）后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效。

2.加权标记

- 加权标记法需要将树中**所有节点都增设一个权值**，用以表示**该节点所在树中的高度**（比如用rank[x]=3表示 x 节点所在树的高度为3）。这样一来，在合并操作的时候就能通过这个权值的大小来决定谁当谁的上级（玄慈哭了：“正义终会来到，但永不会缺席”）。
在合并操作的时候，假设需要合并的两个集合的代表元（教主）分别为 x 和 y，则只需要令pre[x] = y 或者pre[y] = x 即可。但我们为了使合并后的树不产生退化（即：**使树中左右子树的深度差尽可能小**），那么对于每一个元素 x ，增设一个rank[x]数组，用以表达子树 x 的高度。在合并时，如果rank[x] < rank[y]，则令pre[x] = y；否则令pre[y] = x。
- 加权标记法的核心在于对rank数组的逻辑控制，其主要的情况有：
1、如果rank[x] < rank[y]，则令pre[x] = y；
2、如果rank[x] == rank[y]，则可任意指定上级；
3、如果rank[x] > rank[y]，则令pre[y] = x；

```java
void union(int x, int y){
    x=find(x);//寻找 x 的代表元
    y=find(y);//寻找 y 的代表元
    if(x==y)return ;//如果 x 和 y 的代表元一致，说明他们共属同一集合，则不需要合并，直接返回
    if(rank[x]>rank[y])pre[y]=x;//如果 x 比 y 高，则令 y 的上级指向 x
    else{
        if(rank[x]==rank[y])rank[y]++;//如果 x 和 y 的高度相同，则令 y 的高度加 1
        pre[x]=y;//否则，令 x 的上级指向 y
    }
}
